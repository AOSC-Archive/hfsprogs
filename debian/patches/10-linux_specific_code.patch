Author: Rog√©rio Brito <rbrito@ime.usp.br>
Description:
  Modify some of the files so that they can be compiled without the
  Apple owned frameworks in a Debian system (and possibly others).
--- a/fsck_hfs.tproj/cache.c
+++ b/fsck_hfs.tproj/cache.c
@@ -26,7 +26,11 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#if LINUX
+#include "missing.h"
+#else
 #include <sys/types.h>
+#endif /* __LINUX__ */
 #include <sys/uio.h>
 #include <unistd.h>
 #include <string.h>
--- a/fsck_hfs.tproj/dfalib/BTree.c
+++ b/fsck_hfs.tproj/dfalib/BTree.c
@@ -1705,7 +1705,9 @@
 								 UInt16					 version,
 								 BTreeInfoRec			*info )
 {
+#if !LINUX
 #pragma unused (version)
+#endif
 
 	BTreeControlBlockPtr	btreePtr;
 
--- a/fsck_hfs.tproj/dfalib/BlockCache.c
+++ b/fsck_hfs.tproj/dfalib/BlockCache.c
@@ -20,6 +20,9 @@
  * @APPLE_LICENSE_HEADER_END@
  */
 
+#if LINUX
+#include "missing.h"
+#endif
 #include "SRuntime.h"
 #include "Scavenger.h"
 #include "../cache.h"
--- a/fsck_hfs.tproj/dfalib/SBTree.c
+++ b/fsck_hfs.tproj/dfalib/SBTree.c
@@ -322,7 +322,9 @@
 OSStatus
 SetEndOfForkProc ( SFCB *filePtr, FSSize minEOF, FSSize maxEOF )
 {
+#if !LINUX
 #pragma unused (maxEOF)
+#endif
 
 	OSStatus	result;
 	UInt32		actualSectorsAdded;
--- a/fsck_hfs.tproj/dfalib/SDevice.c
+++ b/fsck_hfs.tproj/dfalib/SDevice.c
@@ -2,7 +2,7 @@
  * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
  *
  * @APPLE_LICENSE_HEADER_START@
- * 
+ *
  * "Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
  * Reserved.  This file contains Original Code and/or Modifications of
  * Original Code as defined in and that are subject to the Apple Public
@@ -10,7 +10,7 @@
  * except in compliance with the License.  Please obtain a copy of the
  * License at http://www.apple.com/publicsource and read it before using
  * this file.
- * 
+ *
  * The Original Code and all software distributed under the License are
  * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
  * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
@@ -18,7 +18,7 @@
  * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
  * License for the specific language governing rights and limitations
  * under the License."
- * 
+ *
  * @APPLE_LICENSE_HEADER_END@
  */
 #include "SRuntime.h"
@@ -30,8 +30,16 @@
 #include <errno.h>
 #include <sys/ioctl.h>
 
+#if LINUX
+
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#else
 #include <IOKit/storage/IOMediaBSDClient.h>
 
+
+#endif /* LINUX */
 #else
 
 #include <Files.h>
@@ -46,16 +54,53 @@
 #if BSD
 	UInt64 devBlockCount = 0;
 	int devBlockSize = 0;
+#if LINUX
+	struct stat stbuf;
 
+	devBlockSize = 512;
+
+#ifndef BLKGETSIZE
+#define BLKGETSIZE              _IO(0x12,96)
+#endif
+#ifndef BLKGETSIZE64
+#define BLKGETSIZE64            _IOR(0x12,114,size_t)
+#endif
+	if (fstat(driveRefNum, &stbuf) < 0){
+		plog("Error: %s\n", strerror(errno));
+		return(-1);
+	}
+
+        if (S_ISREG(stbuf.st_mode)) {
+                devBlockCount = stbuf.st_size / 512;
+        }
+        else if (S_ISBLK(stbuf.st_mode)) {
+                unsigned long size;
+                u_int64_t size64;
+                if (!ioctl(driveRefNum, BLKGETSIZE64, &size64))
+                        devBlockCount = size64 / 512;
+                else if (!ioctl(driveRefNum, BLKGETSIZE, &size))
+                        devBlockCount = size;
+                else{
+                        plog("Error: %s\n", strerror(errno));
+			return(-1);
+		}
+
+        }
+        else{
+                plog("Device is not a block device");
+		return(-1);
+	}
+#elif BSD
 	if (ioctl(driveRefNum, DKIOCGETBLOCKCOUNT, &devBlockCount) < 0) {
 	plog("ioctl(DKIOCGETBLOCKCOUNT) for fd %d: %s\n", driveRefNum, strerror(errno));
 		return (-1);
 	}
-	
+
 	if (ioctl(driveRefNum, DKIOCGETBLOCKSIZE, &devBlockSize) < 0) {
 	plog("ioctl(DKIOCGETBLOCKSIZE) for fd %d: %s\n", driveRefNum, strerror(errno));
 		return (-1);
 	}
+#endif /* BSD */
 
 	if (devBlockSize != 512) {
 		*numBlocks = (devBlockCount * (UInt64)devBlockSize) / 512;
@@ -71,24 +116,24 @@
 	{
 		/* return format list status code */
 		kFmtLstCode = 6,
-		
+
 		/* reference number of .SONY driver */
 		kSonyRefNum = 0xfffb,
-		
+
 		/* values returned by DriveStatus in DrvSts.twoSideFmt */
 		kSingleSided = 0,
 		kDoubleSided = -1,
 		kSingleSidedSize = 800,		/* 400K */
 		kDoubleSidedSize = 1600,	/* 800K */
-		
+
 		/* values in DrvQEl.qType */
 		kWordDrvSiz = 0,
 		kLongDrvSiz = 1,
-		
+
 		/* more than enough formatListRecords */
 		kMaxFormatListRecs = 16
 	};
-	
+
 	ParamBlockRec	pb;
 	FormatListRec	formatListRecords[kMaxFormatListRecs];
 	DrvSts			status;
@@ -96,22 +141,22 @@
 	OSErr			result;
 	unsigned long	blocks			= 0;
 
-	
+
 	/* Attempt to get the drive's format list. */
 	/* (see the Technical Note "What Your Sony Drives For You") */
-	
+
 	pb.cntrlParam.ioVRefNum = driveQElementPtr->dQDrive;
 	pb.cntrlParam.ioCRefNum = driveQElementPtr->dQRefNum;
 	pb.cntrlParam.csCode = kFmtLstCode;
 	pb.cntrlParam.csParam[0] = kMaxFormatListRecs;
 	*(long *)&pb.cntrlParam.csParam[1] = (long)&formatListRecords[0];
-	
+
 	result = PBStatusSync(&pb);
-	
+
 	if ( result == noErr )
 	{
 		/* The drive supports ReturnFormatList status call. */
-		
+
 		/* Get the current disk's size. */
 		for( formatListRecIndex = 0;
 			 formatListRecIndex < pb.cntrlParam.csParam[0];
@@ -132,7 +177,7 @@
 	else if ( driveQElementPtr->dQRefNum == (short)kSonyRefNum )
 	{
 		/* The drive is a non-SuperDrive floppy which only supports 400K and 800K disks */
-		
+
 		result = DriveStatus(driveQElementPtr->dQDrive, &status);
 		if ( result == noErr )
 		{
@@ -141,11 +186,11 @@
 				case kSingleSided:
 					blocks = kSingleSidedSize;
 					break;
-					
+
 				case kDoubleSided:
 					blocks = kDoubleSidedSize;
 					break;
-					
+
 				default:		//	This should never happen
 					result = paramErr;
 					break;
@@ -156,20 +201,20 @@
 	{
 		/* The drive is not a floppy and it doesn't support ReturnFormatList */
 		/* so use the dQDrvSz field(s) */
-		
+
 		result = noErr;	/* reset result */
-		
+
 		switch ( driveQElementPtr->qType )
 		{
 			case kWordDrvSiz:
 				blocks = driveQElementPtr->dQDrvSz;
 				break;
-				
+
 			case kLongDrvSiz:
 				blocks = ((unsigned long)driveQElementPtr->dQDrvSz2 << 16) +
 						 driveQElementPtr->dQDrvSz;
 				break;
-				
+
 			default:		//	This should never happen
 				result = paramErr;
 				break;
@@ -178,7 +223,7 @@
 
 	*numBlocks = blocks;
 	*blockSize = 512;
-	
+
 	return( result );
 #endif
 }
@@ -189,7 +234,7 @@
 #if BSD
 	off_t seek_off;
 	ssize_t	nbytes;
-	
+
 	*actBytes = 0;
 
 	seek_off = lseek(device, offset, SEEK_SET);
--- a/fsck_hfs.tproj/dfalib/SKeyCompare.c
+++ b/fsck_hfs.tproj/dfalib/SKeyCompare.c
@@ -454,7 +454,9 @@
  * The name portion of the key is compared using a 16-bit binary comparison. 
  * This is called from the b-tree code.
  */
+#if !LINUX
 __private_extern__
+#endif
 SInt32
 CompareAttributeKeys(const AttributeKey *searchKey, const AttributeKey *trialKey)
 {
--- a/fsck_hfs.tproj/dfalib/SRepair.c
+++ b/fsck_hfs.tproj/dfalib/SRepair.c
@@ -2301,7 +2301,9 @@
 
 static	OSErr	FixWrapperExtents( SGlobPtr GPtr, RepairOrderPtr p )
 {
+#if !LINUX
 #pragma unused (p)
+#endif
 
 	OSErr						err;
 	HFSMasterDirectoryBlock		*mdb;
--- a/fsck_hfs.tproj/dfalib/SRuntime.h
+++ b/fsck_hfs.tproj/dfalib/SRuntime.h
@@ -27,8 +27,11 @@
 #define __SRUNTIME__
 
 #if BSD
-
+#if LINUX
+#include "missing.h"
+#else
 #include <sys/types.h>
+#endif
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -90,10 +93,12 @@
 
 typedef u_int32_t	HFSCatalogNodeID;
 
+#if !LINUX
 enum {
 	false		= 0,
 	true		= 1
 };
+#endif
 
 /* OS error codes */
 enum {
--- a/fsck_hfs.tproj/dfalib/SUtils.c
+++ b/fsck_hfs.tproj/dfalib/SUtils.c
@@ -472,7 +472,8 @@
 //				GPtr->realVCB			Real in-memory vcb
 //------------------------------------------------------------------------------
 
-#if !BSD	
+#if BSD
+#if !LINUX
 OSErr GetVolumeFeatures( SGlobPtr GPtr )
 {
 	OSErr					err;
@@ -510,7 +511,7 @@
 	return( noErr );
 }
 #endif
-
+#endif
 
 
 /*-------------------------------------------------------------------------------
--- a/fsck_hfs.tproj/dfalib/SVerify2.c
+++ b/fsck_hfs.tproj/dfalib/SVerify2.c
@@ -32,7 +32,9 @@
 */
 
 #include <sys/ioctl.h>
+#if !LINUX
 #include <sys/disk.h>
+#endif
 
 #include "BTree.h"
 #include "BTreePrivate.h"
@@ -1353,8 +1355,13 @@
 	 * clump size for read-only media is irrelevant we skip the clump size 
 	 * check to avoid non useful warnings. 
 	 */
+#if LINUX
+	// FIXME
+	isWriteable = 1;
+#else
 	isWriteable = 0;
 	ioctl( GPtr->DrvNum, DKIOCISWRITABLE, &isWriteable );
+#endif
 	if ( isWriteable != 0 && 
 		 volumeHeader->catalogFile.clumpSize != vcb->vcbCatalogFile->fcbClumpSize ) {
 		PrintError(GPtr, E_InvalidClumpSize, 0);
--- a/fsck_hfs.tproj/dfalib/Scavenger.h
+++ b/fsck_hfs.tproj/dfalib/Scavenger.h
@@ -38,15 +38,20 @@
 #include "../fsck_hfs.h"
 
 #include <assert.h>
+#if LINUX
+#define XATTR_MAXNAMELEN 127
+#include <limits.h>
+#else
 #include <sys/xattr.h>
 #include <sys/acl.h>
 #include <sys/kauth.h>
-#include <sys/errno.h>
 #include <sys/syslimits.h>
+#include <hfs/hfs_mount.h>
+#endif
+#include <sys/errno.h>
 #include <sys/param.h>
 #include <sys/sysctl.h>
 #include <sys/mount.h>
-#include <hfs/hfs_mount.h>
 
 #ifdef __cplusplus
 extern	"C" {
@@ -1574,4 +1579,8 @@
 };
 #endif
 
+/* #if LINUX
+#undef XATTR_MAXNAMELEN
+#endif */
+
 #endif /* __SCAVENGER__ */
--- a/fsck_hfs.tproj/dfalib/hfs_endian.c
+++ b/fsck_hfs.tproj/dfalib/hfs_endian.c
@@ -31,7 +31,11 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#if LINUX
+#include "missing.h"
+#else
 #include <architecture/byte_order.h>
+#endif
 #include <hfs/hfs_format.h>
 
 #include "Scavenger.h"
--- a/fsck_hfs.tproj/dfalib/hfs_endian.h
+++ b/fsck_hfs.tproj/dfalib/hfs_endian.h
@@ -27,9 +27,14 @@
  *
  * This file prototypes endian swapping routines for the HFS/HFS Plus
  * volume format.
- */
+*/
 #include <hfs/hfs_format.h>
+#if LINUX
+#include <endian.h>
+#include <byteswap.h>
+#else
 #include <architecture/byte_order.h>
+#endif
 #include "SRuntime.h"
 
 /*********************/
--- a/fsck_hfs.tproj/fsck_hfs.c
+++ b/fsck_hfs.tproj/fsck_hfs.c
@@ -24,10 +24,14 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/param.h>
+#if !LINUX
 #include <sys/ucred.h>
+#endif
 #include <sys/mount.h>
 #include <sys/ioctl.h>
+#if !LINUX
 #include <sys/disk.h>
+#endif
 
 #include <hfs/hfs_mount.h>
 
@@ -195,8 +199,12 @@
 	if (guiControl)
 		debug = 0; /* debugging is for command line only */
 
+#if LINUX
+// FIXME
+#else
 	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
 		(void)signal(SIGINT, catch);
+#endif
 
 	if (argc < 1) {
 		(void) fplog(stderr, "%s: missing special-device\n", progname);
@@ -230,7 +238,9 @@
 	int chkLev, repLev, logLev;
 	int blockDevice_fd, canWrite;
 	char *unraw, *mntonname;
+#if !LINUX
 	struct statfs *fsinfo;
+#endif
 
 	flags = 0;
 	cdevname = filesys;
@@ -239,6 +249,10 @@
 	unraw = NULL;
 	mntonname = NULL;
 
+#if LINUX
+	// FIXME
+#else
+
 	//
 	// initialize the printing/logging without actually printing anything
 	// DO NOT DELETE THIS or else you can deadlock during a live fsck
@@ -275,10 +289,10 @@
 		    }
 		}
 	}
-
+#endif
 	if (debug && preen)
 		pwarn("starting\n");
-	
+
 	if (setup( filesys, &blockDevice_fd, &canWrite ) == 0) {
 		if (preen)
 			pfatal("CAN'T CHECK FILE SYSTEM.");
@@ -349,6 +363,9 @@
 			}
 		}
 	} else {
+#if LINUX
+	// FIXME
+#else
 		struct statfs stfs_buf;
 		/*
 		 * Check to see if root is mounted read-write.
@@ -358,19 +375,25 @@
 		else
 			flags = 0;
 		ckfini(flags & MNT_RDONLY);
+#endif
 	}
 
 	/* XXX free any allocated memory here */
 
 	if (hotroot && fsmodified) {
+#if !LINUX
 		struct hfs_mount_args args;
+#endif
 		/*
 		 * We modified the root.  Do a mount update on
 		 * it, unless it is read-write, so we can continue.
 		 */
 		if (!preen)
 			plog("\n***** FILE SYSTEM WAS MODIFIED *****\n");
-		if (flags & MNT_RDONLY) {		
+#if LINUX
+		// FIXME
+#else
+		if (flags & MNT_RDONLY) {
 			bzero(&args, sizeof(args));
 			flags |= MNT_UPDATE | MNT_RELOAD;
 			if (mount("hfs", "/", flags, &args) == 0) {
@@ -378,6 +401,7 @@
 				goto ExitThisRoutine;
 			}
 		}
+#endif
 		if (!preen)
 			plog("\n***** REBOOT NOW *****\n");
 		sync();
@@ -428,11 +452,13 @@
 		plog("Can't stat %s: %s\n", dev, strerror(errno));
 		return (0);
 	}
+#if !LINUX
 	if ((statb.st_mode & S_IFMT) != S_IFCHR) {
 		pfatal("%s is not a character device", dev);
 		if (reply("CONTINUE") == 0)
 			return (0);
 	}
+#endif
 	if ((fsreadfd = open(dev, O_RDONLY)) < 0) {
 		plog("Can't open %s: %s\n", dev, strerror(errno));
 		return (0);
@@ -455,10 +481,14 @@
 		plog("\n");
 
 	/* Get device block size to initialize cache */
+#if LINUX
+	devBlockSize = 512;
+#else
 	if (ioctl(fsreadfd, DKIOCGETBLOCKSIZE, &devBlockSize) < 0) {
 		pfatal ("Can't get device block size\n");
 		return (0);
 	}
+#endif
 
 	 /* calculate the cache block size and total blocks */
 	if (CalculateCacheSize(userCacheSize, &cacheBlockSize, &cacheTotalBlocks, debug) != 0) {
@@ -485,11 +515,15 @@
 
 static void getWriteAccess( char *dev, int *blockDevice_fdPtr, int *canWritePtr )
 {
+#if !LINUX
 	int					i;
 	int					myMountsCount;
+#endif
 	void *				myPtr;
 	char *				myCharPtr;
+#if !LINUX
 	struct statfs *		myBufPtr;
+#endif
 	void *				myNamePtr;
 
 	myPtr = NULL;
@@ -512,6 +546,9 @@
 	}
 	
 	// get count of mounts then get the info for each 
+#if LINUX
+	// FIXME
+#else
 	myMountsCount = getfsstat( NULL, 0, MNT_NOWAIT );
 	if ( myMountsCount < 0 )
 		goto ExitThisRoutine;
@@ -535,8 +572,8 @@
 		}
 		myBufPtr++;
 	}
-	*canWritePtr = 1;  // single user will get us here, f_mntfromname is not /dev/diskXXXX 
-	
+#endif
+	*canWritePtr = 1;  // single user will get us here, f_mntfromname is not /dev/diskXXXX
 ExitThisRoutine:
 	if ( myPtr != NULL )
 		free( myPtr );
--- a/fsck_hfs.tproj/utilities.c
+++ b/fsck_hfs.tproj/utilities.c
@@ -57,8 +57,9 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/errno.h>
-#include <sys/syslimits.h>
+#include <limits.h>
 #include <pwd.h>
+#include <signal.h>
 
 #include <ctype.h>
 #include <err.h>
@@ -186,12 +187,14 @@
 		plog("Can't stat %s\n", raw);
 			return (origname);
 		}
+#if !LINUX
 		if ((stchar.st_mode & S_IFMT) == S_IFCHR) {
 			return (raw);
 		} else {
 		plog("%s is not a character device\n", raw);
 			return (origname);
 		}
+#endif
 	} else if ((stblock.st_mode & S_IFMT) == S_IFCHR && !retried) {
 		newname = unrawname(newname);
 		retried++;
@@ -217,7 +220,11 @@
 	*dp = 0;
 	(void)strcpy(rawbuf, name);
 	*dp = '/';
-	(void)strcat(rawbuf, "/r");
+#if LINUX
+	(void)strcat(rawbuf, "/");
+#else
+	(void)strcat(rawbuf,"/r");
+#endif
 	(void)strcat(rawbuf, &dp[1]);
 
 	return (rawbuf);
@@ -562,11 +569,13 @@
 {
     int ret;
     size_t size_remaining;
-    va_list ap=NULL;
+    va_list ap;
     char *str=NULL;
 
+    va_copy(ap, NULL);
+
     if (type == DO_VPRINT) {
-	ap = (va_list)arg;
+	va_copy(ap, arg);
     } else if (type == DO_STR) {
 	str = (char *)arg;
     }
--- /dev/null
+++ b/include/missing.h
@@ -0,0 +1,119 @@
+#ifndef _MISSING_H_
+#define _MISSING_H_
+
+#include <endian.h>
+#include <byteswap.h>
+#include <errno.h>
+#include <stdint.h>
+#include <string.h>
+
+#define MAXBSIZE		(256 * 4096)
+
+#ifndef true
+#define true			1
+#endif
+#ifndef false
+#define false			0
+#endif
+
+/* Mac types */
+
+/* 8 Bit */
+#ifndef UInt8
+#define UInt8			uint8_t
+#endif
+#ifndef u_int8_t
+#define u_int8_t		UInt8
+#endif
+#ifndef SInt8
+#define SInt8			int8_t
+#endif
+
+/* 16 Bit */
+#ifndef UInt16
+#define UInt16			uint16_t
+#endif
+#ifndef u_int16_t
+#define u_int16_t		UInt16
+#endif
+#ifndef SInt16
+#define SInt16			int16_t
+#endif
+
+/* 32 Bit */
+#ifndef UInt32
+#define UInt32			uint32_t
+#endif
+#ifndef u_int32_t
+#define u_int32_t		UInt32
+#endif
+#ifndef SInt32
+#define SInt32			int32_t
+#endif
+
+/* 64 Bit */
+#ifndef UInt64
+#define UInt64			uint64_t
+#endif
+#ifndef u_int64_t
+#define u_int64_t		UInt64
+#endif
+#ifndef SInt64
+#define SInt64			int64_t
+#endif
+
+#define UniChar			u_int16_t
+#define Boolean			u_int8_t
+
+#define UF_NODUMP	0x00000001
+
+/* syslimits.h */
+#define NAME_MAX	255
+
+/* Byteswap stuff */
+#define NXSwapHostLongToBig(x)		cpu_to_be64(x)
+#define NXSwapBigShortToHost(x) 	be16_to_cpu(x)
+#define OSSwapBigToHostInt16(x)		be16_to_cpu(x)
+#define NXSwapBigLongToHost(x)		be32_to_cpu(x)
+#define OSSwapBigToHostInt32(x)		be32_to_cpu(x)
+#define NXSwapBigLongLongToHost(x) 	be64_to_cpu(x)
+#define OSSwapBigToHostInt64(x)		be64_to_cpu(x)
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+/* Big Endian Swaps */
+#ifndef be16_to_cpu
+#define be16_to_cpu(x) bswap_16(x)
+#endif
+#ifndef be32_to_cpu
+#define be32_to_cpu(x) bswap_32(x)
+#endif
+#ifndef be64_to_cpu
+#define be64_to_cpu(x) bswap_64(x)
+#endif
+#ifndef cpu_to_be64
+#define cpu_to_be64(x) bswap_64(x)
+#endif
+#elif __BYTE_ORDER == __BIG_ENDIAN
+/* Big endian doesn't swap */
+#ifndef be16_to_cpu
+#define be16_to_cpu(x)	(x)
+#endif
+#ifndef be32_to_cpu
+#define be32_to_cpu(x)	(x)
+#endif
+#ifndef be64_to_cpu
+#define be64_to_cpu(x)	(x)
+#endif
+#ifndef cpu_to_be64
+#define cpu_to_be64(x) 	(x)
+#endif
+#endif
+
+/* dirty workaround for BSD's strlcpy (missing from glibc) */
+#ifndef strlcpy
+#define strlcpy(t, s, size) { strncpy(t, s, (size)-1); t[(size)-1] = '\0'; }
+#endif
+
+#define KAUTH_FILESEC_XATTR "com.apple.system.Security"
+
+#endif
--- a/newfs_hfs.tproj/hfs_endian.c
+++ b/newfs_hfs.tproj/hfs_endian.c
@@ -30,9 +30,15 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#include <architecture/byte_order.h>
 #include <hfs/hfs_format.h>
 
+#if LINUX
+#include "missing.h"
+#else
+#include <architecture/byte_order.h>
+
+#endif
+
 #include "hfs_endian.h"
 
 #undef ENDIAN_DEBUG
--- a/newfs_hfs.tproj/hfs_endian.h
+++ b/newfs_hfs.tproj/hfs_endian.h
@@ -29,7 +29,12 @@
  * volume format.
  */
 #include <hfs/hfs_format.h>
+#if LINUX
+#include <endian.h>
+#include <byteswap.h>
+#else
 #include <architecture/byte_order.h>
+#endif
 
 /*********************/
 /* BIG ENDIAN Macros */
--- a/newfs_hfs.tproj/makehfs.c
+++ b/newfs_hfs.tproj/makehfs.c
@@ -31,10 +31,16 @@
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/time.h>
+#if LINUX
+#include <time.h>
+#include "missing.h"
+#endif
 #include <sys/errno.h>
 #include <sys/stat.h>
 #include <sys/sysctl.h>
+#if !LINUX
 #include <sys/vmmeter.h>
+#endif
 
 #include <err.h>
 #include <errno.h>
@@ -45,6 +51,8 @@
 #include <string.h>
 #include <unistd.h>
 
+#include <openssl/sha.h>
+#if !LINUX
 /*
  * CommonCrypto is meant to be a more stable API than OpenSSL.
  * Defining COMMON_DIGEST_FOR_OPENSSL gives API-compatibility
@@ -62,10 +70,10 @@
 
 extern Boolean _CFStringGetFileSystemRepresentation(CFStringRef string, UInt8 *buffer, CFIndex maxBufLen);
 
-
 #include <hfs/hfs_format.h>
 #include <hfs/hfs_mount.h>
 #include "hfs_endian.h"
+#endif
 
 #include "newfs_hfs.h"
 #include "readme.h"
@@ -135,7 +143,9 @@
 static void MarkBitInAllocationBuffer __P((HFSPlusVolumeHeader *header,
 		UInt32 allocationBlock, void* sectorBuffer, UInt32 *sector));
 
+#if !LINUX
 static UInt32 GetDefaultEncoding();
+#endif
 
 static UInt32 UTCToLocal __P((UInt32 utcTime));
 
@@ -164,6 +174,9 @@
 
 #define ROUNDUP(x, u)	(((x) % (u) == 0) ? (x) : ((x)/(u) + 1) * (u))
 
+#if LINUX
+#define ENCODING_TO_BIT(e)       (e)
+#endif
 #if TARGET_OS_EMBEDDED
 #define ENCODING_TO_BIT(e)				 \
 	  ((e) < 48 ? (e) : 0)
@@ -539,6 +552,7 @@
 	 * Map UTF-8 input into a Mac encoding.
 	 * On conversion errors "untitled" is used as a fallback.
 	 */
+#if !LINUX
 	{
 		UniChar unibuf[kHFSMaxVolumeNameChars];
 		CFStringRef cfstr;
@@ -564,7 +578,11 @@
 		bcopy(&mdbp->drVN[1], defaults->volumeName, mdbp->drVN[0]);
 		defaults->volumeName[mdbp->drVN[0]] = '\0';
 	}
+#endif
 	/* Save the encoding hint in the Finder Info (field 4). */
+	mdbp->drVN[0] = strlen(defaults->volumeName);
+	bcopy(defaults->volumeName,&mdbp->drVN[1],mdbp->drVN[0]);
+
 	mdbp->drFndrInfo[4] = SET_HFS_TEXT_ENCODING(defaults->encodingHint);
 
 	mdbp->drWrCnt = kWriteSeqNum;
@@ -1111,9 +1129,11 @@
 	UInt16					nodeSize;
 	SInt16					offset;
 	UInt32					unicodeBytes;
+#if !LINUX
 	UInt8 canonicalName[256];
 	CFStringRef cfstr;
 	Boolean	cfOK;
+#endif
 	int index = 0;
 
 	nodeSize = dp->catalogNodeSize;
@@ -1133,7 +1153,9 @@
 	 * First record is always the root directory...
 	 */
 	ckp = (HFSPlusCatalogKey *)((UInt8 *)buffer + offset);
-	
+#if LINUX
+	ConvertUTF8toUnicode(dp->volumeName, sizeof(ckp->nodeName.unicode), ckp->nodeName.unicode, &ckp->nodeName.length);
+#else
 	/* Use CFString functions to get a HFSPlus Canonical name */
 	cfstr = CFStringCreateWithCString(kCFAllocatorDefault, (char *)dp->volumeName, kCFStringEncodingUTF8);
 	cfOK = _CFStringGetFileSystemRepresentation(cfstr, canonicalName, sizeof(canonicalName));
@@ -1150,6 +1172,7 @@
 		      dp->volumeName, kDefaultVolumeNameStr);
 	}
 	CFRelease(cfstr);
+#endif
 	ckp->nodeName.length = SWAP_BE16 (ckp->nodeName.length);
 
 	unicodeBytes = sizeof(UniChar) * SWAP_BE16 (ckp->nodeName.length);
@@ -1975,7 +1998,7 @@
 	return quotient;
 }
 
-
+#if !LINUX
 #define __kCFUserEncodingFileName ("/.CFUserTextEncoding")
 
 static UInt32
@@ -2001,7 +2024,7 @@
     }
     return 0;
 }
-
+#endif
 
 static int
 ConvertUTF8toUnicode(const UInt8* source, UInt32 bufsize, UniChar* unibuf,
@@ -2068,6 +2091,9 @@
 static int
 getencodinghint(unsigned char *name)
 {
+#if LINUX
+	return(0);
+#else
         int mib[3];
         size_t buflen = sizeof(int);
         struct vfsconf vfc;
@@ -2085,7 +2111,8 @@
 	return (hint);
 error:
 	hint = GetDefaultEncoding();
-	return (hint);
+	return (0);
+#endif
 }
 
 
@@ -2096,12 +2123,14 @@
 	unsigned char digest[20];
 	time_t now;
 	clock_t uptime;
-	int mib[2];
-	int sysdata;
-	char sysctlstring[128];
 	size_t datalen;
 	double sysloadavg[3];
+#if !LINUX
+	int sysdata;
+	int mib[2];
+	char sysctlstring[128];
 	struct vmtotal sysvmtotal;
+#endif
 	
 	do {
 		/* Initialize the SHA-1 context for processing: */
@@ -2114,52 +2143,58 @@
 		SHA1_Update(&context, &uptime, sizeof(uptime));
 		
 		/* The kernel's boot time: */
+#if !LINUX
 		mib[0] = CTL_KERN;
 		mib[1] = KERN_BOOTTIME;
 		datalen = sizeof(sysdata);
 		sysctl(mib, 2, &sysdata, &datalen, NULL, 0);
 		SHA1_Update(&context, &sysdata, datalen);
-		
+#endif
 		/* The system's host id: */
+#if !LINUX
 		mib[0] = CTL_KERN;
 		mib[1] = KERN_HOSTID;
 		datalen = sizeof(sysdata);
 		sysctl(mib, 2, &sysdata, &datalen, NULL, 0);
 		SHA1_Update(&context, &sysdata, datalen);
-
+#endif
 		/* The system's host name: */
+#if !LINUX
 		mib[0] = CTL_KERN;
 		mib[1] = KERN_HOSTNAME;
 		datalen = sizeof(sysctlstring);
 		sysctl(mib, 2, sysctlstring, &datalen, NULL, 0);
 		SHA1_Update(&context, sysctlstring, datalen);
-
+#endif
 		/* The running kernel's OS release string: */
+#if !LINUX
 		mib[0] = CTL_KERN;
 		mib[1] = KERN_OSRELEASE;
 		datalen = sizeof(sysctlstring);
 		sysctl(mib, 2, sysctlstring, &datalen, NULL, 0);
 		SHA1_Update(&context, sysctlstring, datalen);
-
+#endif
 		/* The running kernel's version string: */
+#if !LINUX
 		mib[0] = CTL_KERN;
 		mib[1] = KERN_VERSION;
 		datalen = sizeof(sysctlstring);
 		sysctl(mib, 2, sysctlstring, &datalen, NULL, 0);
 		SHA1_Update(&context, sysctlstring, datalen);
-
+#endif
 		/* The system's load average: */
 		datalen = sizeof(sysloadavg);
 		getloadavg(sysloadavg, 3);
 		SHA1_Update(&context, &sysloadavg, datalen);
 
 		/* The system's VM statistics: */
+#if !LINUX
 		mib[0] = CTL_VM;
 		mib[1] = VM_METER;
 		datalen = sizeof(sysvmtotal);
 		sysctl(mib, 2, &sysvmtotal, &datalen, NULL, 0);
 		SHA1_Update(&context, &sysvmtotal, datalen);
-
+#endif
 		/* The current GMT (26 ASCII characters): */
 		time(&now);
 		strncpy(randomInputBuffer, asctime(gmtime(&now)), 26);	/* "Mon Mar 27 13:46:26 2000" */
--- a/newfs_hfs.tproj/newfs_hfs.c
+++ b/newfs_hfs.tproj/newfs_hfs.c
@@ -38,8 +38,13 @@
 #include <sys/mount.h>
 #include <sys/param.h>
 #include <sys/stat.h>
+#if LINUX
+#include <time.h>
+#endif
 
+#if !LINUX
 #include <IOKit/storage/IOMediaBSDClient.h>
+#endif
 
 #include <hfs/hfs_format.h>
 #include "newfs_hfs.h"
@@ -73,7 +78,9 @@
 
 char	*progname;
 char	gVolumeName[kHFSPlusMaxFileNameChars + 1] = {kDefaultVolumeNameStr};
+#if !LINUX
 char	rawdevice[MAXPATHLEN];
+#endif
 char	blkdevice[MAXPATHLEN];
 UInt32	gBlockSize = 0;
 UInt32	gNextCNID = kHFSFirstUserCatalogNodeID;
@@ -157,8 +164,10 @@
 	extern int optind;
 	int ch;
 	int forceHFS;
+#if !LINUX
 	char *cp, *special;
 	struct statfs *mp;
+#endif
 	int n;
 	
 	if ((progname = strrchr(*argv, '/')))
@@ -274,6 +283,9 @@
 		if (argc != 1)
 			usage();
 
+#if LINUX
+		(void) sprintf(blkdevice, "%s", argv[0]);
+#else
 		special = argv[0];
 		cp = strrchr(special, '/');
 		if (cp != 0)
@@ -282,6 +294,7 @@
 			special++;
 		(void) snprintf(rawdevice, sizeof(rawdevice), "%sr%s", _PATH_DEV, special);
 		(void) snprintf(blkdevice, sizeof(blkdevice), "%s%s", _PATH_DEV, special);
+#endif
 	}
 
 	if (forceHFS && gJournaled) {
@@ -305,6 +318,9 @@
 		/*
 		 * Check if target device is aready mounted
 		 */
+#if LINUX
+	// FIXME
+#else
 		n = getmntinfo(&mp, MNT_NOWAIT);
 		if (n == 0)
 			fatal("%s: getmntinfo: %s", blkdevice, strerror(errno));
@@ -314,6 +330,7 @@
 				fatal("%s is mounted on %s", blkdevice, mp->f_mntonname);
 			++mp;
 		}
+#endif
 	}
 
 	if (hfs_newfs(rawdevice, forceHFS) < 0) {
@@ -505,7 +522,9 @@
 	int fso = 0;
 	int retval = 0;
 	hfsparams_t defaults = {0};
+#if !LINUX
 	UInt64 maxPhysSectorsPerIO;
+#endif
 	UInt64 physSectorsPerRead;
 	UInt64 physSectorsPerWrite;
 
@@ -524,6 +543,34 @@
 
 		if (fso < 0)
 			fatal("%s: %s", device, strerror(errno));
+#if LINUX
+		dip.sectorSize = 512;
+		dip.sectorsPerIO = 256;
+
+#	ifndef	BLKGETSIZE
+#	define	BLKGETSIZE		_IO(0x12,96)
+#	endif
+
+#	ifndef	BLKGETSIZE64
+#	define BLKGETSIZE64		_IOR(0x12,114,size_t)
+#	endif
+
+		if (S_ISREG(stbuf.st_mode)) {
+		        dip.totalSectors = stbuf.st_size / 512;
+	        }
+		else if (S_ISBLK(stbuf.st_mode)) {
+	                unsigned long size;
+	                u_int64_t size64;
+			if (!ioctl(fso, BLKGETSIZE64, &size64))
+				dip.totalSectors = size64 / 512;
+			else if (!ioctl(fso, BLKGETSIZE, &size))
+				dip.totalSectors = size;
+			else
+				fatal("%s: %s", device, strerror(errno));
+		}
+		else
+			fatal("%s: is not a block device", device);
+#else
 
 		if (fstat( fso, &stbuf) < 0)
 			fatal("%s: %s", device, strerror(errno));
@@ -553,6 +600,7 @@
 
 	dip.sectorSize = kBytesPerSector;
 	dip.totalSectors = dip.physTotalSectors * dip.physSectorSize / dip.sectorSize;
+#endif
 
 	dip.sectorOffset = 0;
 	time(&createtime);
--- a/newfs_hfs.tproj/newfs_hfs.h
+++ b/newfs_hfs.tproj/newfs_hfs.h
@@ -19,8 +19,12 @@
  * 
  * @APPLE_LICENSE_HEADER_END@
  */
- 
+
+#if LINUX
+#include "missing.h"
+#else
 #include <CoreFoundation/CFBase.h>
+#endif
 
 /*
  * Mac OS Finder flags
@@ -122,33 +126,33 @@
 #define kDTDF_FileID	16
 #define kDTDF_Name	"Desktop DF"
 #define kDTDF_Chars	10
-#define kDTDF_Type	'DTFL'
-#define kDTDF_Creator	'DMGR'
+#define kDTDF_Type	0x4454464C /* 'DTFL' */
+#define kDTDF_Creator	0x444D4752 /* 'DMGR' */
 
 #define kDTDB_FileID	17
 #define kDTDB_Name	"Desktop DB"
 #define kDTDB_Chars	10
-#define kDTDB_Type	'BTFL'
-#define kDTDB_Creator	'DMGR'
+#define kDTDB_Type	0x4254464C /* 'BTFL' */
+#define kDTDB_Creator	0x444D4752 /* 'DMGR' */
 #define kDTDB_Size	1024
 
 #define kReadMe_FileID	18
 #define kReadMe_Name	"ReadMe"
 #define kReadMe_Chars	6
-#define kReadMe_Type	'ttro'
-#define kReadMe_Creator	'ttxt'
+#define kReadMe_Type	0x7474726F /* 'ttro' */
+#define kReadMe_Creator	0x74747974 /* 'ttxt' */
 
 #define kFinder_FileID	19
 #define kFinder_Name	"Finder"
 #define kFinder_Chars	6
-#define kFinder_Type	'FNDR'
-#define kFinder_Creator	'MACS'
+#define kFinder_Type	0x464E4452 /* 'FNDR' */
+#define kFinder_Creator	0x4D414353 /* 'MACS' */
 
 #define kSystem_FileID	20
 #define kSystem_Name	"System"
 #define kSystem_Chars	6
-#define kSystem_Type	'zsys'
-#define kSystem_Creator	'MACS'
+#define kSystem_Type	0x7A737973 /* 'zsys' */
+#define kSystem_Creator	0x4D414353 /* 'MACS' */
 
 
 
--- a/fsck_hfs.tproj/fsck_hfs.h
+++ b/fsck_hfs.tproj/fsck_hfs.h
@@ -23,7 +23,7 @@
  */
 
 #include "cache.h"
-
+#include <stdarg.h>
 
 const extern char	*cdevname;		/* name of device being checked */
 extern char	*progname;
